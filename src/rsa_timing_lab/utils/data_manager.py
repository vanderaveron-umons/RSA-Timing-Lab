import csv
from dataclasses import asdict
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple

from rsa_timing_lab.core import TimingData, RSAKey


def _write_csv(
    filename: str,
    data: List[Dict[str, Any]],
    headers: List[str],
    metadata: Optional[Dict[str, Any]] = None
) -> None:
    """
    Generic function to write a list of dictionaries to a CSV file.
    """
    with open(filename, 'wt', newline='') as f:
        # Write metadata as commented header lines
        f.write("# File generated by rsa_timing_lab\n")
        f.write(f"# Date: {datetime.now().isoformat()}\n")
        if metadata:
            for key, value in metadata.items():
                f.write(f"# {key}: {value}\n")
        f.write("#\n")

        writer = csv.DictWriter(f, fieldnames=headers)
        writer.writeheader()
        writer.writerows(data)

def _read_csv(filename: str) -> List[Dict[str, str]]:
    """
    Generic function to read a CSV file into a list of dictionaries.
    Skips any lines that start with '#'.
    """
    with open(filename, 'r') as f:
        # Filter out comment lines before passing to the CSV reader
        csv_content = (line for line in f if not line.strip().startswith('#'))
        reader = csv.DictReader(csv_content)
        return list(reader)


def export_timing_data(
    filename: str,
    data: List[TimingData],
    metadata: Optional[Dict[str, Any]] = None
) -> None:
    """
    Exports a list of TimingData objects to a CSV file.
    """
    headers = ["ciphertext", "timing"]
    # Convert list of dataclasses to list of dicts
    dict_data = [
        {"ciphertext": d.ciphertext, "timing": d.timing} for d in data
    ]
    _write_csv(filename, dict_data, headers, metadata)

def import_timing_data(filename: str) -> List[TimingData]:
    """
    Imports a list of TimingData objects from a CSV file.
    """
    dict_data = _read_csv(filename)
    # Convert list of dicts back to list of dataclasses, with error handling
    timing_data = []
    for row in dict_data:
        try:
            timing_data.append(
                TimingData(ciphertext=int(row["ciphertext"]), timing=float(row["timing"]))
            )
        except (KeyError, ValueError):
            # Skip malformed rows
            continue
    return timing_data

def export_attack_results(
    filename: str,
    data: List[Any],
    metadata: Optional[Dict[str, Any]] = None
) -> None:
    """
    Exports a list of AttackResult objects to a CSV file.
    (Future-proof: ready for your experiment_runner)
    """
    if not data:
        return

    # Convertit les objets dataclass en dictionnaires
    dict_data = [asdict(d) for d in data]

    # Les en-tÃªtes sont extraits du premier objet
    headers = dict_data[0].keys()

    _write_csv(filename, dict_data, list(headers), metadata)

    #headers = ["recovered_key_bits", "attack_time", "samples_used"]
    #dict_data = [
    #    {
    #        "recovered_key_bits": r.recovered_key_bits,
    #        "attack_time": r.attack_time,
    #        "samples_used": r.samples_used
    #    } for r in data
    #]
    #_write_csv(filename, dict_data, headers, metadata)

def export_keys(filename: str, keys_with_config: Dict[str, Tuple[RSAKey, Any]]) -> None:
    """
    Exports RSA keys along with their generation seeds to a CSV file.
    """
    headers = ["trial_id", "key_size", "key_seed", "sample_seed", "n", "e", "d", "p", "q"]
    dict_data = []
    for trial_id, (key, config) in keys_with_config.items():
        dict_data.append({
            "trial_id": trial_id,
            "key_size": key.n.bit_length(),
            "key_seed": config.key_seed,
            "sample_seed": config.sample_seed,
            "n": key.n, "e": key.e, "d": key.d, "p": key.p, "q": key.q,
        })
    _write_csv(filename, dict_data, headers)


def export_attack_summary(filename: str, summary_data: List[Dict[str, Any]]) -> None:
    """
    Exports summary statistics of an experiment campaign.
    """
    if not summary_data:
        return
    headers = summary_data[0].keys()
    _write_csv(filename, summary_data, headers)
